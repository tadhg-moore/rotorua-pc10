---
title: "CMIP 6 Processing"
format: html
editor: visual
warning: false
message: false
---

```{r}
#| label: setup
#| include: false
#| echo: false
#| cache: true

cmip6_metadata <- readr::read_csv(here::here("data", "processed",
                                             "niwa_cmip6_metadata.csv"), 
                                  col_types = readr::cols())
vcsn_grid_points <- sf::st_read("https://climatedata.environment.govt.nz/data/core_public_data/geospatial/index_grid_points_vcsn_filtered_2193.gpkg")
```

Currently the CMIP6 data we have is in NetCDF format, which is not directly compatible with our model input requirements. Therefore, we need to preprocess this data to extract the relevant variables and reformat them appropriately.

Also there are \>4 TB of data for all of New Zealand on a daily timestep, at a 5x5 km resolution. This is too large to process directly, so we will need to subset the data spatially and temporally.

## Metadata

We have gathered metadata for the CMIP6 datasets available on the shared drive, including information on the variables, scenarios, models, and bias correction methods used.

Further details can be found [here](https://climatedata.environment.govt.nz/).

```{r}
#| label: cmip6-metadata
#| echo: false
#| include: true
#| tbl-cap: "CMIP6 Metadata Overview"

cmip6_metadata |> 
  dplyr::select(variable_name_long, variable, variable_units, scenario, gcm, model, timestep, spatial_res, biascorrection, calendar) |> 
  DT::datatable(options = list(pageLength = 5))
```

## File access

The CMIP6 data is stored on a shared drive (Z: drive) accessible within our institutional network. The files are organized by variable, scenario, model, region, timestep, spatial resolution, and bias correction method e.g "hurs_historical_ACCESS-CM2_CCAM_daily_NZ5km_raw.nc". This corresponds to relative humidity (hurs) for the historical scenario from the ACCESS-CM2 GCM, downscaled using the CCAM model over New Zealand at a daily timestep and 5 km spatial resolution, without bias correction.

Loading and reading data from these NetCDF files can be done using the `ncdf4` package in R. However, reading large datasets can be time-consuming, so we have implemented a function which uses a grid reference system to efficiently extract only the required data points.

This provided as the [VCSN agent data](https://climatedata.environment.govt.nz/core-public-dataset.html#vcsn-agent-data). This contains a grid of points at 5 km resolution covering New Zealand, with each point having a unique coordinate index. We use this grid to identify which points fall within our area of interest, and then extract only those points from the NetCDF files.

```{r}
#| label: vcsn-grid-points
#| echo: false
#| include: true
#| eval: true

library(tmap)
tmap_mode("view")
aoi <- readRDS(here::here("data", "processed", "rotorua_area.rds"))

sub_points <- vcsn_grid_points |>
  sf::st_transform(crs = sf::st_crs(aoi)) |>
  sf::st_intersection(aoi)

tm_shape(sub_points) +
  tm_dots() +
  tm_shape(aoi) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_view = c(176.27, -38.14, 10))

```

## Create an area of interest

If you do not have a shapefile of your area of interest (AOI), you can easily generate one with the [`mapedit`](https://r-spatial.org/r/2019/03/31/mapedit_leafpm.html) package.

```{r}
#| label: draw-aoi
#| echo: true
#| include: true
#| eval: false
x <- mapedit::drawFeatures()

```

Save the drawn features for future use:

```{r}
#| label: save-aoi
#| echo: true
#| include: true
#| eval: false
saveRDS(x, here::here("data", "processed", "rotorua_area.rds"))
```

## Processing function

The `process_cmip6` function takes in a spatial polygon (defining the area of interest), the VCSN grid points, the path to a NetCDF file, and an output file path. It extracts the relevant data points from the NetCDF file based on the area of interest, and saves the processed data to a new NetCDF file.

```{r}
#| label: load-fun-meta
#| echo: false
#| include: true
#| eval: true
#| result: asis

roxy <- roxygen2::parse_file(here::here("R", "process_cmip6.R"))
block <- roxy[[1]]

params <- block$tags[ sapply(block$tags, function(x) x$tag == "param") ]

# List of parameter names and descriptions:
param_list <- lapply(params, function(p) {
  list(name = p$val[[1]], description = p$val[[2]])
})

# Convert into a table for markdown
param_table <- do.call(rbind, lapply(param_list, function(p) {
  data.frame(
    Parameter = paste0("`", p$name, "`"),
    Description = p$description,
    stringsAsFactors = FALSE
  )
}))

knitr::kable(param_table, format = "markdown", 
                 caption = "Function Parameters for `process_cmip6()`")


```

```{r}
#| label: process-cmip6-function
#| echo: true
#| include: true
#| eval: false

source(here::here("R", "process_cmip6.R"))
process_cmip6(x = x, vcsn_grid_points = vcsn_grid_points,
              file = file, outfile = outfile)
```
